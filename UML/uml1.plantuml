@startuml
skinparam classAttributeIconSize 0
skinparam classFontStyle Bold
hide enum methods


package models {

    package game{

        enum GameState{
            CONFIG
            PLACEMENT
            IN_GAME
            ENDGAME
        }

        enum GameMode{
            NORMAL
            ISLAND
        }

        class Game implements .models.player.PlayerObserver{
            -currentPlayer:Integer
            +<<create>>Game()
            +setUpGameMode(gameMode:GameMode)
            +setUpPlayer(player[2]:Player)
            +playerAttack(x:Integer;y:Integer,weapon:Weapon)
            +nextTurn()
        }
        Game "1"-->"1 -gameState" GameState
        Game "1" *-->"2 -playerList" .models.player.Player
        Game ..> ConfigData:<<uses>>

        class ConfigData{
            -gridSize:Integer[2]
            +<<create>>ConfigData()
            +setGridSize(x:Integer;y:Integer)
            +setGameMod(gameMode:GameMode)
            +addBoat(boat:Boat)
            +getGridSize()
            +getChosenBoats()
            +getGameMode()

        }

       class Placement{
           +<<create>>Placement(algo:PlacementAlgo,grid:Grid[2])
           +applyPlacement()
           +setPlacementAlgo(algo:PlacementAlgo)
       }


       Placement "1" *--> "1 -placementAlgo" PlacementAlgo

       abstract class PlacementAlgo{
            +placeBoats(boats:Boat[])
            +placeTraps(traps:Trap[])
       }


       class StaticPlacementAlgo extends PlacementAlgo
       class RandomPlacementAlgo extends PlacementAlgo
       class ManualPlacementAlgo extends PlacementAlgo


       ConfigData "1"*-->"1-gameMode"GameMode
       ConfigData "1"o-->"*-boats" .models.placeable.boats.Boats


    }

    package grid {
        class Grid {
            -size : Integer[2]
            +<<create>>Grid(size:Integer[2])
            +setSize(size:Integer[2])
            +changeStateOfTile(x:Integer,y:Integer,state:State)
            +isTileFree(x:Integer;y:Integer):bool
            +placeObject(placeable:Placeable):bool
        }

        Grid ...> .models.placeable.Placeable:<<use>>;

        interface GridObserver {
            +updateGrid()
        }
        Grid "1" o--> "1..* -observer[]" GridObserver

         class Tile{
            -x:Integer
            -y:Integer
            +<<create>>Tile()
            +setState(newState:State)
            +addObserver(observer:TileObserver)
            -notify_observer()
        }

        interface TileObserver {
            +update_tile(state:State)
        }

        Tile "1" o--> "0..* -list_observer" .models.grid.TileObserver
        Grid "1" *--> "1..*" Tile : "-TilesMap[]"

    }
    package placeable{


        class Placeable implements .models.grid.TileObserver {
            +<<create>>Placeable(name:String,position:Integer[2],size:Integer,rotation:bool)
            -size:Integer
            -name:String
            +calculatePosition():Integer[*][2]
            +{abstract}updateTileState(state:State)
        }

        Placeable "1"o-->"-tiles[*]" .models.grid.Tile


    package boats{

        Enum BoatType{
            AIRCRAFTCARRIER=5
            CRUISER=4
            DESTROYER=3
            SUBMARINE=3
            TORPEDOBOAT=2
        }
        Boats ..> BoatType:<<use>>
        abstract class Boats <<abstract>> extends .models.placeable.Placeable{
            +<<create>>Boats(name:String,size:Integer,tile:TopTile,rotation:bool)
            -is_alive:bool
            +notify_observer(life:bool)
            +{abstract}updateTileState(state:State)
        }

        class Submarine extends Boats{
            +<<create>>Submarine()
            +updateTileState(state:State)
        }

        class AircraftCarrier extends Boats{
            +<<create>>AircraftCarrier()
            +updateTileState(state:State)
        }

        class Cruiser extends Boats{
            +<<create>>Cruiser
            +updateTileState(state:State)
        }

        class Destroyer extends Boats{
            +<<create>>Destroyer()
            +updateTileState(state:State)
        }

        class TorpedoBoat extends Boats{
            +<<create>>Torpedo_boat()
            +updateTileState(state:State)
        }

        interface Boats_observer {
            +notifyOnDeath(life:bool)
            +updateTileState(state:State)
        }

        Boats "1" -> "1..* -observer[]" Boats_observer


    }

        package trap{
            abstract class Trap <<abstract>> extends .models.placeable.Placeable{
                -hasBeenActivated:bool
                -hasBeenUse:bool
                +<<create>>Trap(int:OwnerId)
                +{abstract}updateTileState(state:State)
                +{abstract}effect_onHit()
                +setUsed(used:bool):bool
            }

            class Black_hole extends Trap{
                +<<create>>BlackHole(int:OwnerId)
                -name:String
                +update_tile(tile:Tile)
                +effect_onHit()
            }

            class Tornado extends Trap{
                +<<create>>Tornado(int:OwnerId)
                -name:String
                +update_tile(tile:Tile)
                +effect_onHit()
            }
        }





        class PlaceableFactory{
            +<<create>>PlaceableFactory()
            +createCruiser():Boats
            +createDestroyer():Boats
            +createTorpedoBoat():Boats
            +createSubmarine():Boats
            +createAircraftCarrier():Boats
            +createBlackHole():Trap
            +createTornado():Trap
        }


        PlaceableFactory ..> boats.Cruiser : <<uses>>
        PlaceableFactory ..> boats.Destroyer : <<uses>>
        PlaceableFactory ..> boats.TorpedoBoat : <<uses>>
        PlaceableFactory ..> boats.Submarine : <<uses>>
        PlaceableFactory ..> boats.AircraftCarrier : <<uses>>

        PlaceableFactory ..> trap.Tornado : <<uses>>
        PlaceableFactory ..> trap.Black_hole : <<uses>>



        }





    package state{

        Enum StateName{

        }


        interface State {
            +<<create>>State(state:StateName)
            getCurrentState():StateName
            +onHit():State
        }
        StateName<-- State :-currentState

        package unusedTiles{

        class Boat_tile implements .models.state.State{
            +<<create>> Boat_tile()
            +onHit():Boat_hit_tile
        }

        class Empty_tile implements .models.state.State{
            +<<create>> Empty_tile()
            +onHit():Miss_Tile
        }

        class Island_tile implements .models.state.State{
            +<<create>> Island_tile()
            +onHit():Island_Searched_tile
            +setWeapon(weapon:Weapon)
        }
        Island_tile "1"o-->"1" .models.weapon.Weapon

        class Trap_tile implements .models.state.State{
            +<<create>> Trap_tile()
            +onHit():Trap_used_tile
        }


        }

        package usedTiles{

        class Boat_hit_tile implements .models.state.State{
            +<<create>> Boat_tile()
            +onHit():null
        }

        class Boat_dead implements .models.state.State{
            +<<create>> Boat_tile()
            +onHit():null
        }

       class Miss_tile implements .models.state.State{
           +<<create>> Miss_tile()
           +onHit():null
       }

        class Island_Searched_tile implements .models.state.State{
            +<<create>> Island_Searched_tile()
            +onHit():null
        }

        class Trap_used_tile implements .models.state.State{
            +<<create>> Trap_tile()
            +onHit():null
        }

        }

    }

    Tile "select" *-right-> "1 -state" state.State



    package player{
        abstract class Player <<abstract>> implements models.placeable.boats.Boats_observer{
            +<<create>>Player(name:String,grid:Grid)
            -name:String
            -id:Integer
            -isAlive :bool
            +<<abstract>>playerTurn()
            +addBoat(boat:Boat)
            +addTrap(trap:Trap)
            +reactToDeathOfBoat(live:Bool)
            +attack(x:Integer,y:Integer,weapon:Weapon)
            +getAttacked(x:Integer,y:Integer,weapon:Weapon)
            +addObserver(player:PlayerObserver)
        }

        Player "1"o-->"-lstObserver"PlayerObserver
        interface PlayerObserver{
            +<<create>>PlayerObserver()

        }

        class AI extends Player{
            +<<create>>AI()
            +playerTurn()
            +randomPlace()
        }

        class HumanPlayer extends Player{
            +<<create>>HumanPlayer()
            +playerTurn()
        }


        Player "*"o-->"1 -playerGrid" models.grid.Grid
        Player "*"*-->"* -playerBoats[]" models.placeable.boats.Boats
        .controller.PlacementController ..> models.placeable.PlaceableFactory : <<use>>
        Player "*"*--> "2 -playerTraps[]" models.placeable.trap.Trap
        Player ..> .models.weapon.Weapon : <<use>>
        Player "1" *--> "1-stat" .models.log.Stats
        Player  ..> .models.log.Turn :<<create>>
        Player ..> .models.log.Log : <<use>>
    }

    package weapon{
            enum EffectType {
                HIT=1
                SCAN=0
            }
            class Effect{
                +<<create>>Effect(x:Integer,y:Integer,effect:EffectType)
                -x: Integer
                -y: Integer
                +getPos():Integer[]
                +getDamage():Integer
            }
            interface Weapon {
                +use(x:Integer, y:Integer):Effect[]
            }

            class Missile implements Weapon {
                +use(x, y):Effect[]
            }

            class Bomber implements Weapon {
                +use(x, y):Effect[]
            }

            class Sonar implements Weapon {
                +use(x, y):Effect[]
            }
            Effect *-->"1 -effect" EffectType
            Weapon "1" ..> "*" Effect : <<returns>>

        }

    package log{
        class Log <<static>>{
            +{static}addLog(turn:Turn)
        }
        Log *--> "*-lstTurn"Turn
        class Turn{
            +<<create>>turn(player:string,x:Integer;y:Integer,weapon:string,re:string)
        }

        Stats o--> "-lastTurn" Turn
        class Stats{
            -boat:Integer
            -boatHit: Integer
            -boatSunk: Integer

            +<<create>>Stats()

        }

    }



}


package App{
   class App{
    +main(args:String[])
   }



   App ..> .controller.ApplicationController : <<create>>


}



package controller {

    class ApplicationController{
        +<<create>>ApplicationController()
        +switchToScreen()
    }

    ApplicationController "1"-->"* -screens" .views.UserScreen
    ApplicationController ..> .models.grid.Grid : <<create>>
    ApplicationController ..> .models.player.Player : <<create>>
    ApplicationController ..> .models.game.Game :<<create>>

    ApplicationController ..> .controller.ConfigController : <<create>>
    ApplicationController ..> .controller.PlacementController : <<create>>
    ApplicationController ..> .controller.PlayerController : <<create>>
    ApplicationController ..> .controller.EndController : <<create>>


    ApplicationController ..> .views.ConfigScreen : <<create>>
    ApplicationController ..> .views.PlacementScreen : <<create>>
    ApplicationController ..> .views.MainScreen : <<create>>
    ApplicationController ..> .views.EndGameScreen : <<create>>

    class PlayerController{
        +<<create>>PlayerController()
        +requestAttackFromPlayer(x:Integer;y:Integer)
        +selectWeapon(weapon:Weapon)

    }

    PlayerController "1"o-->"2 -lstPlayer" .models.player.Player

    class ConfigController{
        +<<create>>ConfigController(grid:Grid[2])
        +selectGameMode(gameMode:GameMode)
        +getAvailableBoats():Boat[]
        +selectBoats(boat:Boat)
    }

    ConfigController "1"-->"1-config" ConfigData
    ConfigController "1"-->"2 -lstGrid" .models.grid.Grid


    class PlacementController{
        +<<create>>PlacementController(player[2]:Player,grid:Grid[2])
        +generateRandomPlacement()
        +applyStaticPlacement()
        +enableManualPlacement()
    }
    PlacementController "1" o-left-> "2 -lstPlayer" models.player.Player
    PlacementController "1"o-left->"2 -lstGrid" Grid

}



package views {


    class UserScreen <<abstract>> {
        -name:String
        +<<create>>UserScreen(name:String)
        +hide()
        +show()
    }

    class ConfigScreen extends UserScreen{
        +<<create>>ConfigScreen(controller:ConfigController)
        +setGridSize(size:Integer[2])
        +chooseGameMode(gameMode:GameMode)
        +setBoatCount(type:String,count:Integer)
        +confirm()
    }

    ConfigScreen --> "1 -configController" controller.ConfigController
    ConfigScreen ..>.models.game.GameMode:<<use>>



    class PlacementScreen extends UserScreen{
        +<<create>>PlacementScreen(controller:PlacementController)
        +displayInitialStaticPlacement()
        +requestRandomPlacement()
        +enableManualPlacementMode()
    }
    PlacementScreen --> controller.PlacementController : "1 -placementController"
    PlacementScreen "1"o-->"1 -placementController".controller.PlacementController

    class MainScreen extends UserScreen implements .models.grid.Grid.GridObserver{
        +<<create>>MainScreen()
        +chooseWeapon():Weapon
        +displayWeaponChoice()
    }


    class EndGameScreen extends UserScreen{
        +<<create>>EndGameScreen()
        +setUpLogs()
        +showLogs()
        +restartTheGame()
    }
    EndGameScreen ..> .models.controller.stat.Stat



}


@enduml