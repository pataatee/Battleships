@startuml
!option handwritten true
skinparam classAttributeIconSize 0
skinparam classFontStyle Bold
hide enum methods
skinparam Padding 3
skinparam ClassFontSize 11
skinparam PackageFontSize 13
skinparam linetype ortho


package models {

    package game{

        enum GameState{
            CONFIG
            PLACEMENT
            IN_GAME
            ENDGAME
        }

        enum shotResult{
            TOUCHED,
            COULED,
            MISSED,
            TRAPPED,
            ISLANDED,
            ISLANDEDFOUNDED
        }

        enum GameMode{
            NORMAL
            ISLAND
        }

        interface GameObserver{
            +updateNewTurn(turnNumber:Integer)
            +updateCurrentPlayerIndex(playerIndex:Integer)
            +updateAttackExecuted(attack:Attack,target:Player)
            +updateGameState(state:GameState)
            +updateGameOver(winner:Player)
        }

        Game "1"o-->"* -observer" GameObserver

        class Game{
            -currentPlayerIndex:Integer
            -currentTurn:Integer
            +<<create>>Game(player1:Player,player2:Player)
            +setUpGameMode(gameMode:GameMode)
            +startGame()
            +executeHumanAttack(x:Integer;y:Integer)
            +executeAITurn()
            +AITurnDelayer()
            +nextTurn()
            +getOpponent():Player
            +endGame(winner:Player)
            +getCurrentPlayer():Player
            +isHumanTurn():Boolean
            +getGameMode():GameMode
            +getCurrentTurn():Integer
            +getCurrentPlayerIndex():Integer
            +getGameState():GameState
            +addObserver(observer:GameObserver)
            +notifyNextTurn()
            +notifyNextPlayer()
            +notifyAttackExecuted()
            +notifyGameStateChanged()
            +notifyGameOver(winner:Player)
        }

        Game "1"-->"1 -gameState" GameState
        Game "1"-->"1 -gameMode" GameMode
        Game "1"-->"2 -players" Player
        Game "1" *-->"2 -playerList" .models.player.Player
        Game ..>.models.player.PlayerType:<<use>>

        class ConfigData{
            -gridSize:Integer
            +<<create>>ConfigData()
            +setGridSize(size:Integer)
            +setGameMod(gameMode:GameMode)
            +addBoat(boat:Boat)
            +getGridSize()
            +getChosenBoats()
            +getGameMode()

        }

       class Placement{
           +<<create>>Placement(strat:PlacementStrategy)
           +setPlacementStrategy(algo:PlacementStrategy)
           +placeObject(placeable:Placeable[*],grid:Grid)
       }

       enum Orientation{
        HORIZONTAL,
        VERTICAL
       }

       enum StaticPositions{
        AIRCRAFTCARRIERDEFAULTPOS,
        CRUISERDEFAULTPOS,
        DESTROYERDEFAULTPOS,
        SUBMARINEDEFAULTPOS,
        TORPEDOBOATDEFAULTPOS,
        BLACKHOLEDEFAULTPOS,
        TORNADODEFAULTPOS
       }


       Placement "1" *--> "1 -placementStrategy" PlacementStrategy
       Placement "1" o--> "1" .models.grid.Grid:<<uses>>

       abstract class PlacementStrategy{
            +<<create>>PlacementStrategy()
            +{{abstract}}placeObjects(placeable:Placeable[*],grid:Grid)
       }

       PlacementStrategy ..> .models.grid.Grid
       PlacementStrategy o--> "1" .models.placeable.Placeable
       PlacementStrategy ..>StaticPositions:<<use>>
       PlacementStrategy ..>Orientation:<<uses>>

       class StaticPlacementStrategy extends PlacementStrategy{
           +<<create>>PlacementStrategy()
           +placeObjects(placeable:Placeable[*],grid:Grid)
       }

       class RandomPlacementStrategy extends PlacementStrategy{
           +<<create>>PlacementStrategy()
           +placeObjects(placeable:Placeable[*],grid:Grid)
       }

       class ManualPlacementStrategy extends PlacementStrategy{
          +<<create>>PlacementStrategy()
          +placeObjects(placeable:Placeable[*],grid:Grid)
       }


       ConfigData "1"*-->"1-gameMode"GameMode
       ConfigData "1"o-->"*-boats" .models.placeable.boats.Boats


    }

    package grid {
        class Grid {
            -size : Integer
            +<<create>>Grid(size:Integer)
            +setSize(size:Integer)
            +generateGrid()
            +changeStateOfTile(x:Integer,y:Integer,newState:TileState)
            +hitTile(x:Integer,y:Integer)
            +isTileFree(x:Integer;y:Integer):bool
            +placeObject(placeable:Placeable,x:(x:Integer;y:Integer)):bool
            +addObserver(observer:GridObserver)
            +notifyObserver()
            +getSize():Integer
            +getTileTileState():TileState
        }

        Grid ...> .models.placeable.Placeable:<<use>>
        Grid "1" o--> "1..* -observer[]" GridObserver
        Grid "1" -->"1" .models.game.placement.Orientation
        Grid "1" --> "1".models.placeable.Placeable
        Grid "1" -->"1" .models.placeable.PlaceableType

        interface GridObserver {
            +updateTileState(x:Integer,y:Integer,state:State)
        }

         abstract class Tile{
            +<<create>>Tile()
            +setState(state:TileState)
            +isFree():Boolean
            +getStateName():TileState
            + {abstract}onHit()
            +setObject(object:Placeable)
            +getObject():Placeable
            -notify_observer()
        }

        class IslandTile extends Tile {
            +<<create>>IslandTile()
            + onHit()
            + addWeapon(weapon:Weapon)
            + addTrap(trap:Trap)
        }


        class SeaTile extends Tile {
            +<<create>>SeaTile()
            + onHit()
            + addPlaceable(placeable:Placeable)
        }

        SeaTile o--> "-_object" .models.placeable.Placeable
        SeaTile *--> "-_state" SeaTileState

        IslandTile o--> "-_object" .models.placeable.Placeable
        IslandTile -->"1 -weapon" .models.weapon.Weapon
        IslandTile *--> "-_state" IslandTileState

        enum TileState {
            EMPTY
            MISS
            BOAT
            BOATHIT
            TRAP
            TRAPHIT
            SEARCHED
            NOTSEARCHED
        }

        Grid "1" *--> "1..*" Tile : "-TilesMap[]"

    }
    package placeable{


    abstract class Placeable {
        +<<create>>Placeable(name:String,position:Integer[2],size:Integer,rotation:bool)
        -size:Integer
        -name:String
        +calculatePosition():Integer[*][2]
        +{abstract}onHit()
    }

    Placeable "1"o-->"-tiles[*]" .models.grid.Tile

   class emptyTile extends Placeable{
        +<<create>>emptyTile();
        +onHit()
   }


    package boats{

        Enum BoatType{
            AIRCRAFTCARRIER=5
            CRUISER=4
            DESTROYER=3
            SUBMARINE=3
            TORPEDOBOAT=2
        }
        Boats ..> BoatType:<<use>>
        abstract class Boats <<abstract>> extends .models.placeable.Placeable{
            +<<create>>Boats(name:String,size:Integer,tile:TopTile,rotation:bool)
            -is_alive:bool
            +notify_observer(life:bool)
            +onHit()
        }

        class Submarine extends Boats{
            +<<create>>Submarine()
        }

        class AircraftCarrier extends Boats{
            +<<create>>AircraftCarrier()
        }

        class Cruiser extends Boats{
            +<<create>>Cruiser
        }

        class Destroyer extends Boats{
            +<<create>>Destroyer()
        }

        class TorpedoBoat extends Boats{
            +<<create>>Torpedo_boat()
        }

        interface Boats_observer {
            +notifyOnDeath(life:bool)
            +updateTileState(state:State)
        }

        Boats "1" -> "1..* -observer[]" Boats_observer


    }

        package trap{
            abstract class Trap <<abstract>> extends .models.placeable.Placeable{
                -hasBeenActivated:bool
                -hasBeenUse:bool
                +<<create>>Trap(int:OwnerId)
                +{abstract}updateTileState(state:State)
                +{abstract}effect_onHit()
                +setUsed(used:bool):bool
            }

            class Black_hole extends Trap{
                +<<create>>BlackHole(int:OwnerId)
                -name:String
                +update_tile(tile:Tile)
                +effect_onHit()
            }

            class Tornado extends Trap{
                +<<create>>Tornado(int:OwnerId)
                -name:String
                +update_tile(tile:Tile)
                +effect_onHit()
            }
        }





        class PlaceableFactory{
            +<<create>>PlaceableFactory()
            +createCruiser():Boats
            +createDestroyer():Boats
            +createTorpedoBoat():Boats
            +createSubmarine():Boats
            +createAircraftCarrier():Boats
            +createBlackHole():Trap
            +createTornado():Trap
        }


        PlaceableFactory ..> boats.Cruiser : <<uses>>
        PlaceableFactory ..> boats.Destroyer : <<uses>>
        PlaceableFactory ..> boats.TorpedoBoat : <<uses>>
        PlaceableFactory ..> boats.Submarine : <<uses>>
        PlaceableFactory ..> boats.AircraftCarrier : <<uses>>

        PlaceableFactory ..> trap.Tornado : <<uses>>
        PlaceableFactory ..> trap.Black_hole : <<uses>>
        PlaceableFactory ..> emptyTile : <<uses>>



        }



    package player{
        abstract class Player <<abstract>> implements models.placeable.boats.Boats_observer{
            +<<create>>Player(name:String,grid:Grid)
            -name:String
            -id:Integer
            -isAlive :bool
            +<<abstract>>playerTurn()
            +addBoat(boat:Boat)
            +addTrap(trap:Trap)
            +reactToDeathOfBoat(live:Bool)
            +attack(x:Integer,y:Integer,weapon:Weapon)
            +getAttacked(x:Integer,y:Integer,weapon:Weapon)
            +notifyEndTurn()
            +notifyDeath(death:bool)
        }

        class AI extends Player{
            +<<create>>AI()
            +playerTurn()
            +randomPlace()
        }

        class HumanPlayer extends Player{
            +<<create>>HumanPlayer()
            +playerTurn()
        }


        Player "*"o-->"1 -playerGrid" models.grid.Grid
        Player "*"*-->"* -playerBoats[]" models.placeable.boats.Boats
        Player "*"*--> "2 -playerTraps[]" models.placeable.trap.Trap
        Player ..> .models.weapon.Weapon : <<use>>
        Player "1" *--> "1-stat" .models.log.Stats
        Player  ..> .models.log.Turn :<<create>>
        Player ..> .models.log.Log : <<use>>
    }

    package weapon{
            enum EffectType {
                HIT=1
                SCAN=0
            }
            class Effect{
                +<<create>>Effect(x:Integer,y:Integer,effect:EffectType)
                -x: Integer
                -y: Integer
                +getPos():Integer[]
                +getDamage():Integer
            }

            class WeaponFactory{
                +<<create>>WeaponFactory()
                +createMissile():Weapon
                +createBomber():Weapon
                +createSonar():Weapon
            }

            WeaponFactory ..> Missile :<<create>>
            WeaponFactory ..> Bombe :<<create>>
            WeaponFactory ..> Sonar :<<create>>


            interface Weapon {
                +use(x:Integer, y:Integer):Effect[]
            }

            class Missile implements Weapon {
                +use(x, y):Effect[]
            }

            class Bombe implements Weapon {
                +use(x, y):Effect[]
            }

            class Sonar implements Weapon {
                +use(x, y):Effect[]
            }
            Effect *-->"1 -effect" EffectType
            Weapon "1" ..> "*" Effect : <<returns>>

        }

    package log{
        class Log <<static>>{
            +{static}addLog(turn:Turn)
        }
        Log *--> "*-lstTurn"Turn
        class Turn{
            +<<create>>turn(player:string,x:Integer;y:Integer,weapon:string,re:string)
        }

        Stats o--> "-lastTurn" Turn
        class Stats{
            -boat:Integer
            -boatHit: Integer
            -boatSunk: Integer

            +<<create>>Stats()

        }

    }



}


package App{
   class App{
    +main(args:String[])
   }

}



package controller {


    enum ScreenType{
        CONFIG
        PLACEMENT
        MAIN_GAME
        END_GAME
    }

    .App.App ..> .models.game.Game : <<creates>>
    .App.App..> .models.grid.Grid : <<creates>>
    .App.App ..> .models.player.Player : <<creates>>
    .App.App ..> .models.game.Placement : <<creates>>

    .App.App ..> .views.ConfigScreen : <<creates>>
    .App.App ..> .views.PlacementScreen : <<creates>>
    .App.App ..> .views.MainScreen : <<creates>>
    .App.App ..> .views.EndGameScreen : <<creates>>


    .App.App ..> ConfigController : <<creates>>
    .App.App ..> PlacementController : <<creates>>
    .App.App ..> PlayerController : <<creates>>
    .App.App ..> EndController : <<creates>>

    class PlayerController{
        +<<create>>PlayerController(player:Player,game:Game)
        +requestAttackFromPlayer(x:Integer;y:Integer)
        +selectWeapon(weapon:Weapon)
        +onGameEnd()
    }

    PlayerController "1"o-->"1 -humanPlayer" .models.player.Player
    PlayerController "1"o-->"1 -game" .models.game.Game

    class ConfigController{
        +<<create>>ConfigController(grids:Grid[2])
        +selectGameMode(gameMode:GameMode)
        +getAvailableBoats():Boat[]
        +selectBoats(boat:Boat)
        +confirmConfiguration()
    }

    ConfigController "1"o-->"1 -configData" .models.game.ConfigData
    ConfigController "1"o-->"2 -lstGrid" .models.grid.Grid


    class PlacementController{
        +<<create>>PlacementController(placement:Placement)
        +generateRandomPlacement()
        +applyStaticPlacement()
        +enableManualPlacement()
        +confirmPlacement()
    }

    PlacementController "1" o--> "1 -placement" .models.game.Placement
    PlacementController ..> .models.placeable.PlaceableFactory : <<use>>
    PlacementController ..> .models.game.StaticPlacementStrategy : <<creates>>
    PlacementController ..> .models.game.RandomPlacementStrategy : <<creates>>
    PlacementController ..> .models.game.ManualPlacementStrategy : <<creates>>

    class EndController {
        +<<create>>EndController()
        +restartGame()
        +quitGame()
    }



}



package views {


    abstract class UserScreen <<abstract>> {
        -name:String
        +<<create>>UserScreen(name:String)
        +hide()
        +show()
        +onScreenComplete()
    }

    class ConfigScreen extends UserScreen{
        +<<create>>ConfigScreen(controller:ConfigController)
        +setGridSize(size:Integer)
        +chooseGameMode(gameMode:GameMode)
        +setBoatCount(type:String,count:Integer)
        +confirm()
    }

    ConfigScreen "1" o--> "1 -configController" controller.ConfigController
    ConfigScreen ..>.models.game.GameMode:<<use>>



    class PlacementScreen extends UserScreen{
        +<<create>>PlacementScreen(controller:PlacementController)
        +displayInitialStaticPlacement()
        +requestRandomPlacement()
        +enableManualPlacementMode()
        +confirmPlacement()
    }
    PlacementScreen "1"o-->"1 -placementController".controller.PlacementController

    class MainScreen extends UserScreen implements .models.game.GameObserver{
        +<<create>>MainScreen(controller:PlayerController)
        +chooseWeapon():Weapon
        +displayWeaponChoice()
        +onGameEnd()
    }

    MainScreen "1" o--> "1 -playerController" controller.PlayerController
    MainScreen "1"*-->"1 -weaponFactory" .models.weapon.WeaponFactory



    class EndGameScreen extends UserScreen{
        +<<create>>EndGameScreen(controller:EndController)
        +setUpLogs()
        +showLogs()
        +restartTheGame()
    }
    EndGameScreen ..> .models.log.Stats :<<use>>
    EndGameScreen ..> .models.log.Log :<<use>>
    EndGameScreen "1"o-->"1 -endController" .controller.EndController

    class GridDisplay implements .models.grid.GridObserver{
        +<<create>>GridDisplay(grid:Grid)
        +updateTileState(x:Integer,y:Integer,state:State)
    }
    MainScreen "1"*-->"2 -gridDisplay" GridDisplay
    PlacementScreen "1"*-->"1 playerGrid" GridDisplay

}


@enduml