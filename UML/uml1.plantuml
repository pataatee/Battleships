@startuml
!option handwritten true
skinparam classAttributeIconSize 0
skinparam classFontStyle Bold
hide enum methods
skinparam Padding 3
skinparam ClassFontSize 11
skinparam PackageFontSize 13
skinparam linetype ortho


package models {

    package game{

        enum GameState{
            CONFIG
            PLACEMENT
            IN_GAME
            ENDGAME
        }

        enum GameMode{
            NORMAL
            ISLAND
        }

        interface GameObserver{
            +UpdateNewTurn(turn:Integer)
            +UpdateCurrentPlayerIndex(index:Integer)
        }

        Game "1"o-->"* -observer" GameObserver

        class Game implements .models.player.PlayerObserver{
            -currentPlayerIndex:Integer
            -currentTurn:Integer
            +<<create>>Game()
            +setUpGameMode(gameMode:GameMode)
            +setUpPlayer(player[2]:Player)
            +playerAttack(x:Integer;y:Integer,weapon:Weapon)
            +nextTurn()
            +notifyObserverNewTurn()
            +notifyObserverCurrentPlayerIndex()
        }
        Game "1"-->"1 -gameState" GameState
        Game "1" *-->"2 -playerList" .models.player.Player
        Game ..> ConfigData:<<uses>>

        class ConfigData{
            -gridSize:Integer
            +<<create>>ConfigData()
            +setGridSize(size:Integer)
            +setGameMod(gameMode:GameMode)
            +addBoat(boat:Boat)
            +getGridSize()
            +getChosenBoats()
            +getGameMode()

        }

       class Placement{
           +<<create>>Placement(grids:Grid[2],players:Player[2])
           +applyPlacement(boats:Boat[])
           +setPlacementAlgo(algo:PlacementAlgo)
           +randomPlacement(boats:Boat[])
           +staticPlacement(boats:Boat[])
           +manualPlacement(boats:Boat[])
       }


       Placement "1" *--> "1 -placementAlgo" PlacementAlgo
       Placement "1" o--> "2 -grids" .models.grid.Grid
       Placement "1" o--> "2 -players" .models.player.Player

       abstract class PlacementAlgo{
            -grid:Grid
            -player:Player
            +<<create>>PlacementAlgo(grid:Grid,player:Player)
            +{abstract}placeBoats(boats:Boat[])
            +{abstract}placeTraps(traps:Trap[])
       }

       PlacementAlgo o--> "1" .models.grid.Grid
       PlacementAlgo o--> "1" .models.player.Player

       class StaticPlacementAlgo extends PlacementAlgo{
           +<<create>>StaticPlacementAlgo(grid:Grid,player:Player)
           +placeBoats(boats:Boat[])
           +placeTraps(traps:Trap[])
       }

       class RandomPlacementAlgo extends PlacementAlgo{
           +<<create>>RandomPlacementAlgo(grid:Grid,player:Player)
           +placeBoats(boats:Boat[])
           +placeTraps(traps:Trap[])
       }

       class ManualPlacementAlgo extends PlacementAlgo{
           +<<create>>ManualPlacementAlgo(grid:Grid,player:Player)
           +placeBoats(boats:Boat[])
           +placeTraps(traps:Trap[])
           +waitForUserInput()
       }


       ConfigData "1"*-->"1-gameMode"GameMode
       ConfigData "1"o-->"*-boats" .models.placeable.boats.Boats


    }

    package grid {
        class Grid {
            -size : Integer
            +<<create>>Grid(size:Integer)
            +setSize(size:Integer)
            +generateGrid()
            +changeStateOfTile(x:Integer,y:Integer,state:State)
            +isTileFree(x:Integer;y:Integer):bool
            +placeObject(placeable:Placeable):bool
            +addObserver(observer:GridObserver)
            +notifyObserver()
        }

        Grid ...> .models.placeable.Placeable:<<use>>;

        interface GridObserver {
            +updateTileState(x:Integer,y:Integer,state:State)
        }
        Grid "1" o--> "1..* -observer[]" GridObserver

         class Tile{
            -x:Integer
            -y:Integer
            +<<create>>Tile()
            +setState(newState:State)
            +addObserver(observer:TileObserver)
            -notify_observer()
        }

        interface TileObserver {
            +update_tile(state:State)
        }

        Tile "1" o--> "0..* -list_observer" .models.grid.TileObserver
        Grid "1" *--> "1..*" Tile : "-TilesMap[]"

    }
    package placeable{


        abstract class Placeable implements .models.grid.TileObserver {
            +<<create>>Placeable(name:String,position:Integer[2],size:Integer,rotation:bool)
            -size:Integer
            -name:String
            +calculatePosition():Integer[*][2]
            +{abstract}updateTileState(state:State)
        }

        Placeable "1"o-->"-tiles[*]" .models.grid.Tile


    package boats{

        Enum BoatType{
            AIRCRAFTCARRIER=5
            CRUISER=4
            DESTROYER=3
            SUBMARINE=3
            TORPEDOBOAT=2
        }
        Boats ..> BoatType:<<use>>
        abstract class Boats <<abstract>> extends .models.placeable.Placeable{
            +<<create>>Boats(name:String,size:Integer,tile:TopTile,rotation:bool)
            -is_alive:bool
            +notify_observer(life:bool)
            +{abstract}updateTileState(state:State)
        }

        class Submarine extends Boats{
            +<<create>>Submarine()
            +updateTileState(state:State)
        }

        class AircraftCarrier extends Boats{
            +<<create>>AircraftCarrier()
            +updateTileState(state:State)
        }

        class Cruiser extends Boats{
            +<<create>>Cruiser
            +updateTileState(state:State)
        }

        class Destroyer extends Boats{
            +<<create>>Destroyer()
            +updateTileState(state:State)
        }

        class TorpedoBoat extends Boats{
            +<<create>>Torpedo_boat()
            +updateTileState(state:State)
        }

        interface Boats_observer {
            +notifyOnDeath(life:bool)
            +updateTileState(state:State)
        }

        Boats "1" -> "1..* -observer[]" Boats_observer


    }

        package trap{
            abstract class Trap <<abstract>> extends .models.placeable.Placeable{
                -hasBeenActivated:bool
                -hasBeenUse:bool
                +<<create>>Trap(int:OwnerId)
                +{abstract}updateTileState(state:State)
                +{abstract}effect_onHit()
                +setUsed(used:bool):bool
            }

            class Black_hole extends Trap{
                +<<create>>BlackHole(int:OwnerId)
                -name:String
                +update_tile(tile:Tile)
                +effect_onHit()
            }

            class Tornado extends Trap{
                +<<create>>Tornado(int:OwnerId)
                -name:String
                +update_tile(tile:Tile)
                +effect_onHit()
            }
        }





        class PlaceableFactory{
            +<<create>>PlaceableFactory()
            +createCruiser():Boats
            +createDestroyer():Boats
            +createTorpedoBoat():Boats
            +createSubmarine():Boats
            +createAircraftCarrier():Boats
            +createBlackHole():Trap
            +createTornado():Trap
        }


        PlaceableFactory ..> boats.Cruiser : <<uses>>
        PlaceableFactory ..> boats.Destroyer : <<uses>>
        PlaceableFactory ..> boats.TorpedoBoat : <<uses>>
        PlaceableFactory ..> boats.Submarine : <<uses>>
        PlaceableFactory ..> boats.AircraftCarrier : <<uses>>

        PlaceableFactory ..> trap.Tornado : <<uses>>
        PlaceableFactory ..> trap.Black_hole : <<uses>>



        }





    package state{

        Enum StateName{

        }


        interface State {
            +<<create>>State(state:StateName)
            getCurrentState():StateName
            +onHit():State
        }
        StateName<--* State :-currentState

        package unusedTiles{

        class Boat_tile implements .models.state.State{
            +<<create>> Boat_tile()
            +onHit():Boat_hit_tile
        }

        class Empty_tile implements .models.state.State{
            +<<create>> Empty_tile()
            +onHit():Miss_Tile
        }

        class Island_tile implements .models.state.State{
            +<<create>> Island_tile()
            +onHit():Island_Searched_tile
            +setWeapon(weapon:Weapon)
        }
        Island_tile "1"o-->"1" .models.weapon.Weapon

        class Trap_tile implements .models.state.State{
            +<<create>> Trap_tile()
            +onHit():Trap_used_tile
        }


        }

        package usedTiles{

        class Boat_hit_tile implements .models.state.State{
            +<<create>> Boat_tile()
            +onHit():null
        }

        class Boat_dead implements .models.state.State{
            +<<create>> Boat_tile()
            +onHit():null
        }

       class Miss_tile implements .models.state.State{
           +<<create>> Miss_tile()
           +onHit():null
       }

        class Island_Searched_tile implements .models.state.State{
            +<<create>> Island_Searched_tile()
            +onHit():null
        }

        class Trap_used_tile implements .models.state.State{
            +<<create>> Trap_tile()
            +onHit():null
        }

        }

    }

    Tile "select" *-right-> "1 -state" state.State



    package player{
        abstract class Player <<abstract>> implements models.placeable.boats.Boats_observer{
            +<<create>>Player(name:String,grid:Grid)
            -name:String
            -id:Integer
            -isAlive :bool
            +<<abstract>>playerTurn()
            +addBoat(boat:Boat)
            +addTrap(trap:Trap)
            +reactToDeathOfBoat(live:Bool)
            +attack(x:Integer,y:Integer,weapon:Weapon)
            +getAttacked(x:Integer,y:Integer,weapon:Weapon)
            +addObserver(player:PlayerObserver)
            +notifyEndTurn()
            +notifyDeath(death:bool)
        }

        Player "1"o-->"-lstObserver"PlayerObserver
        interface PlayerObserver{
            +<<create>>PlayerObserver()
            +notifyEndTurn()
            +notifyDeath(death:bool)
        }

        class AI extends Player{
            +<<create>>AI()
            +playerTurn()
            +randomPlace()
        }

        class HumanPlayer extends Player{
            +<<create>>HumanPlayer()
            +playerTurn()
        }


        Player "*"o-->"1 -playerGrid" models.grid.Grid
        Player "*"*-->"* -playerBoats[]" models.placeable.boats.Boats
        Player "*"*--> "2 -playerTraps[]" models.placeable.trap.Trap
        Player ..> .models.weapon.Weapon : <<use>>
        Player "1" *--> "1-stat" .models.log.Stats
        Player  ..> .models.log.Turn :<<create>>
        Player ..> .models.log.Log : <<use>>
    }

    package weapon{
            enum EffectType {
                HIT=1
                SCAN=0
            }
            class Effect{
                +<<create>>Effect(x:Integer,y:Integer,effect:EffectType)
                -x: Integer
                -y: Integer
                +getPos():Integer[]
                +getDamage():Integer
            }

            class WeaponFactory{
                +<<create>>WeaponFactory()
                +createMissile():Weapon
                +createBomber():Weapon
                +createSonar():Weapon
            }

            WeaponFactory ..> Missile :<<create>>
            WeaponFactory ..> Bombe :<<create>>
            WeaponFactory ..> Sonar :<<create>>


            interface Weapon {
                +use(x:Integer, y:Integer):Effect[]
            }

            class Missile implements Weapon {
                +use(x, y):Effect[]
            }

            class Bombe implements Weapon {
                +use(x, y):Effect[]
            }

            class Sonar implements Weapon {
                +use(x, y):Effect[]
            }
            Effect *-->"1 -effect" EffectType
            Weapon "1" ..> "*" Effect : <<returns>>

        }

    package log{
        class Log <<static>>{
            +{static}addLog(turn:Turn)
        }
        Log *--> "*-lstTurn"Turn
        class Turn{
            +<<create>>turn(player:string,x:Integer;y:Integer,weapon:string,re:string)
        }

        Stats o--> "-lastTurn" Turn
        class Stats{
            -boat:Integer
            -boatHit: Integer
            -boatSunk: Integer

            +<<create>>Stats()

        }

    }



}


package App{
   class App{
    +main(args:String[])
   }



   App ..> .controller.ApplicationController : <<create>>


}



package controller {

    interface ControllerObserver{
        +onControllerComplete(nextScreen:ScreenType)
    }

    enum ScreenType{
        CONFIG
        PLACEMENT
        MAIN_GAME
        END_GAME
    }

    abstract class BaseController{
        +addObserver(observer:ControllerObserver)
        -notifyCompletion(nextScreen:ScreenType)
    }

    BaseController "1" o--> "* -observers" ControllerObserver

    class ApplicationController implements ControllerObserver{
        +<<create>>ApplicationController()
        +start()
        +onControllerComplete(nextScreen:ScreenType)
    }

    ApplicationController "1" *--> "1 -screenManager" ScreenManager
    ApplicationController "1" *--> "1 -gameFactory" GameFactory
    ApplicationController "1" *--> "1 -screenFactory" ScreenFactory
    ApplicationController "1" *--> "1 -controllerFactory" ControllerFactory

    class ScreenManager{
        +<<create>>ScreenManager()
        +switchToScreen(screenType:ScreenType)
        +registerScreen(type:ScreenType,screen:UserScreen)
        +getCurrentScreen():UserScreen
    }

    ScreenManager "1" o--> "* -screens" .views.UserScreen
    ScreenManager ..> ScreenType : <<use>>

    class GameFactory{
        +<<create>>GameFactory()
        +createGame(configData:ConfigData):Game
        +createGrids(size:Integer):Grid[2]
        +createPlayers(grids:Grid[2]):Player[2]
        +createPlacement(grids:Grid[2],players:Player[2]):Placement
    }

    GameFactory ..> .models.game.Game : <<creates>>
    GameFactory ..> .models.grid.Grid : <<creates>>
    GameFactory ..> .models.player.Player : <<creates>>
    GameFactory ..> .models.game.Placement : <<creates>>

    class ScreenFactory{
        +<<create>>ScreenFactory()
        +createConfigScreen(controller:ConfigController):ConfigScreen
        +createPlacementScreen(controller:PlacementController):PlacementScreen
        +createMainScreen(controller:PlayerController):MainScreen
        +createEndGameScreen(controller:EndController):EndGameScreen
    }

    ScreenFactory ..> .views.ConfigScreen : <<creates>>
    ScreenFactory ..> .views.PlacementScreen : <<creates>>
    ScreenFactory ..> .views.MainScreen : <<creates>>
    ScreenFactory ..> .views.EndGameScreen : <<creates>>

    class ControllerFactory{
        +<<create>>ControllerFactory()
        +createConfigController(grids:Grid[2]):ConfigController
        +createPlacementController(placement:Placement):PlacementController
        +createPlayerController(player:Player,game:Game):PlayerController
        +createEndController():EndController
    }

    ControllerFactory ..> ConfigController : <<creates>>
    ControllerFactory ..> PlacementController : <<creates>>
    ControllerFactory ..> PlayerController : <<creates>>
    ControllerFactory ..> EndController : <<creates>>

    class PlayerController extends BaseController{
        +<<create>>PlayerController(player:Player,game:Game)
        +requestAttackFromPlayer(x:Integer;y:Integer)
        +selectWeapon(weapon:Weapon)
        +onGameEnd()
    }

    PlayerController "1"o-->"1 -humanPlayer" .models.player.Player
    PlayerController "1"o-->"1 -game" .models.game.Game

    class ConfigController extends BaseController{
        +<<create>>ConfigController(grids:Grid[2])
        +selectGameMode(gameMode:GameMode)
        +getAvailableBoats():Boat[]
        +selectBoats(boat:Boat)
        +confirmConfiguration()
    }

    ConfigController "1"o-->"1 -configData" .models.game.ConfigData
    ConfigController "1"o-->"2 -lstGrid" .models.grid.Grid


    class PlacementController extends BaseController{
        +<<create>>PlacementController(placement:Placement)
        +generateRandomPlacement()
        +applyStaticPlacement()
        +enableManualPlacement()
        +confirmPlacement()
    }

    PlacementController "1" o--> "1 -placement" .models.game.Placement
    PlacementController ..> .models.placeable.PlaceableFactory : <<use>>
    PlacementController ..> .models.game.StaticPlacementAlgo : <<creates>>
    PlacementController ..> .models.game.RandomPlacementAlgo : <<creates>>
    PlacementController ..> .models.game.ManualPlacementAlgo : <<creates>>

    class EndController extends BaseController{
        +<<create>>EndController()
        +restartGame()
        +quitGame()
    }



}



package views {


    abstract class UserScreen <<abstract>> {
        -name:String
        +<<create>>UserScreen(name:String)
        +hide()
        +show()
        +onScreenComplete()
    }

    class ConfigScreen extends UserScreen{
        +<<create>>ConfigScreen(controller:ConfigController)
        +setGridSize(size:Integer)
        +chooseGameMode(gameMode:GameMode)
        +setBoatCount(type:String,count:Integer)
        +confirm()
    }

    ConfigScreen "1" o--> "1 -configController" controller.ConfigController
    ConfigScreen ..>.models.game.GameMode:<<use>>



    class PlacementScreen extends UserScreen{
        +<<create>>PlacementScreen(controller:PlacementController)
        +displayInitialStaticPlacement()
        +requestRandomPlacement()
        +enableManualPlacementMode()
        +confirmPlacement()
    }
    PlacementScreen "1"o-->"1 -placementController".controller.PlacementController

    class MainScreen extends UserScreen implements .models.game.GameObserver{
        +<<create>>MainScreen(controller:PlayerController)
        +chooseWeapon():Weapon
        +displayWeaponChoice()
        +onGameEnd()
    }

    MainScreen "1" o--> "1 -playerController" controller.PlayerController
    MainScreen "1"*-->"1 -weaponFactory" .models.weapon.WeaponFactory



    class EndGameScreen extends UserScreen{
        +<<create>>EndGameScreen(controller:EndController)
        +setUpLogs()
        +showLogs()
        +restartTheGame()
    }
    EndGameScreen ..> .models.log.Stats :<<use>>
    EndGameScreen ..> .models.log.Log :<<use>>
    EndGameScreen "1"o-->"1 -endController" .controller.EndController

    class GridDisplay implements .models.grid.GridObserver{
        +<<create>>GridDisplay(grid:Grid)
        +updateTileState(x:Integer,y:Integer,state:State)
    }
    MainScreen "1"*-->"2 -gridDisplay" GridDisplay
    PlacementScreen "1"*-->"1 playerGrid" GridDisplay

}


@enduml